from scipy.spatial import ConvexHull
import numpy as np
import matplotlib.pyplot as plt

def randTropicalPolynomial(degree, numVar):
	""" randomTropicalPolynomial: creates a tropical polynomial of the
		specified degree and number of variables, but all of the 
		coefficients are pulled independently from a random normal 
		distribution.
		
		Inputs:
			degree - the degree of the polynomial. Must be a positive
				integer.
			numVar - the number of variables in the equation. Must be
				a positive integer.
		
		Outputs:
			A numpy matrix. Each row corresponds to a monomial of the
			polynomial and each of the columns (besides the last) 
			represents one of the variables, and the last column
			represents the coefficient. A monomial like "2.3x^2yz^5" 
			would be encoded as [2 1 5 2.3].
	"""

	if numVar==1:
		# If there is only one variable, then we construct the column
		# of powers,
		columnOfPowers = np.linspace(0, degree, num=1+degree)
		columnOfPowers = np.transpose(np.matrix(columnOfPowers))
		
		# then the column of random values,
		columnOfCoef = np.random.randn(degree+1,1)
		
		# then combine them horizontally.
		polynomial = np.concatenate((columnOfPowers, columnOfCoef),1)
		
	else:

		polynomialNotYetCreated = True
		
		# Then for each possible power the first variable can have:
		for powerOfFirstVariable in range(degree+1):
			
			# We create all of the terms that have the specified power
			# for the first variable.
			
			# We create a random polynomial that doesn't have the 
			# first variable, and multiply each entry with the first 
			# variable raised to the specified power.
			randPolynomial = randTropicalPolynomial(degree - 
				powerOfFirstVariable, numVar-1)
			numEntries = randPolynomial.shape[0]
			firstVariable = np.zeros((numEntries,1)) + 
				powerOfFirstVariable
			newEntries = np.concatenate((firstVariable, 
				randPolynomial),1)
			
			if polynomialNotYetCreated:
				polynomial = newEntries
				polynomialNotYetCreated = False
			else:
				polynomial = np.concatenate((polynomial,newEntries))
	
	return(polynomial)

 def polynomialType(polynomial):
	""" polynomialType: determines the "type" of the tropical
		polynomial. Given an arbitrary polynomial, the function will
		find the coresponding subdivision of the newton polytope.
		
		Inputs:
			polynomial - a tropical polynomial
		
		Outputs:
			An ordered list of simplices. Each simplex defines one
			component of the newton subdivision, and the indices in 
			each simplex refer to which term of the subdivision is 
			generated by.
	"""
	
	numColumns = polynomial.shape[1]
	
	# Create the first support point
	firstSupportPoint = np.zeros((1,numColumns)) - 1
	firstSupportPoint[0,numColumns-1] = 1000
	
	# Create the second support point.
	secondSupportPoint = np.max(polynomial,0) + 1
	secondSupportPoint[0,numColumns-1] = 1000
	
	# Now, we get the points, and take the convex hull.
	points = np.concatenate((firstSupportPoint, secondSupportPoint, 
							 polynomial))
	hull = ConvexHull(points)
	
	# We obtain the lower side of the convex hull by removing the two 
	# supports,
	newSimplices = hull.simplices - 2
	newSimplices = [simplex for simplex in newSimplices if not 
		(-2 in simplex)]
	newSimplices = [simplex for simplex in newSimplices if not 
		(-1 in simplex)]

	# and then reindex and sort the list of remaining simplices.
	newSimplices = [simplex.tolist() for simplex in newSimplices]
	[simplex.sort() for simplex in newSimplices]
	newSimplices.sort()
	
	# Then we return the new simplices.
	return(newSimplices)

def drawPolynomial_1variable(polynomial):
	""" drawPolynomial_1variable: draws out the newton polytope and
		the corresponding subdivision of the provided polynomial. It 
		is assumed that the polynomial is of only one variable.
		
		Input:
			polynomial - an arbitrary polynomial in ONE variable.
			
		Output:
			A drawing of the corresponding subdivision.
	"""
	
	# Obtain what the type is, and what terms are connected.
	simplices = polynomialType(polynomial)
		
	# Now plot out those connections.
	for simplex in simplices:
		vertex1x = polynomial[simplex[0],0]
		vertex2x = polynomial[simplex[1],0]
		plt.plot(vertex1x, 0, 'o')
		plt.plot(vertex2x, 0, 'o')
		plt.plot([vertex1x,vertex2x],[0,0], 'k--')
	plt.show()

# Example usage:
# poly = randTropicalPolynomial(3,1)
# drawPolynomial_1variable(poly)

def drawPolynomial_2variables(polynomial):
	""" drawPolynomial_2variable: draws out the newton polytope and 
		the corresponding subdivision of the provided polynomial. It 
		is assumed that the polynomial is of two variables.
		
		Input:
			polynomial - an arbitrary polynomial in TWO variables.
			
		Output:
			A drawing of the corresponding subdivision.
	"""
	
	# Obtain what the type is, and what terms are connected.
	simplices = polynomialType(polynomial)
		
	# Now plot out those connections.
	for simplex in simplices:
		vertex1x = polynomial[simplex[0],0]
		vertex1y = polynomial[simplex[0],1]
		vertex2x = polynomial[simplex[1],0]
		vertex2y = polynomial[simplex[1],1]
		vertex3x = polynomial[simplex[2],0]
		vertex3y = polynomial[simplex[2],1]
		plt.fill([vertex1x,vertex2x,vertex3x,vertex1x], \
				 [vertex1y,vertex2y,vertex3y,vertex1y], \
				 ec='k')
	plt.show()

# Example usage:
# poly = randTropicalPolynomial(4,2)
# drawPolynomial_2variables(poly)

# This is an example piece of code for finding the the sample 
# distributions for tropical polynomials of degree three in one 
# variable.
dictionary = {}
for j in range(10000):
	poly = randTropicalPolynomial(3,1)
	combType = str(polynomialType(poly))
	
	if combType in dictionary:
		dictionary[combType] += 1
	else:
		dictionary[combType] = 1

print(dictionary)
